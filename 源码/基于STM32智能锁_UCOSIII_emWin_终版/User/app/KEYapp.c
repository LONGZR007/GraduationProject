/**************************************************************************************
* 因为emWin显示只支持UTF-8编码格式的中文，如果希望直接显示在Keil直接输入的中文，      *
*            比如使用：GUI_DispStringHCenterAt("流水灯",110,120);                     *
* 该文件必须以UTF-8编码格式，不然中文无法正常显示。                                   *
*                                                                                     *
* 如果只是个别例程出现中文显示乱码（如果所有例程都无法显示中文可能是字库问题），      *
* 把对应的例程文件(比如LEDapp.c)用电脑的记事本软件打开，然后选择另存为，在弹出对      *
* 话框中“保存(S)"按钮的左边有个"编码(E)"选项，选择"UTF-8",然后同样保存为同名称的      *
* C语言文件(覆盖原来文件)，再编译。                                                   *
*                                                                                     *
* 如果编译工程时出现下面类似错误也是该文件编码格式问题,必须把文件保存为UTF-8格式      *
* 再编译                                                                              *
* ..\..\User\app\LEDapp.c(275): error:  #8: missing closing quote                     *
*        GUI_DispStringHCenterAt("娴?姘?鐏?",110,120);                                *
* ..\..\User\app\LEDapp.c(276): error:  #165: too few arguments in function call      *
*        GUI_DispStringHCenterAt("瑙?鎽?鍋?宸?澶?鎵?闇€瑕?瑙?鎽?鏍?鍑?",110,215);     *
* ..\..\User\app\LEDapp.c(276): error:  #18: expected a ")"                           *
*        GUI_DispStringHCenterAt("瑙?鎽?鍋?宸?澶?鎵?闇€瑕?瑙?鎽?鏍?鍑?",110,215);     *
*                                                                                     *
* 修改文件后编译就出错这是Keil5软件问题(Keil4没这问题)，推荐使用其他程序编辑工具，    *
* 只用Keil5完成编译和下载工作。                                                       *
***************************************************************************************
*                      实验平台: 野火STM32 ISO 开发板                                 *
*                      论    坛: http://www.chuxue123.com                             *
*                      淘    宝: http://firestm32.taobao.com                          *
*                      邮    箱: wildfireteam@163.com                                 *
***************************************************************************************
*/
/**************************************************************************************
*                                                                                     *
*                SEGGER Microcontroller GmbH & Co. KG                                 *
*        Solutions for real time microcontroller applications                         *
*                                                                                     *
***************************************************************************************
*                                                                                     *
* C-file generated by:                                                                *
*                                                                                     *
*        GUI_Builder for emWin version 5.22                                           *
*        Compiled Jul  4 2013, 15:16:01                                               *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG                                *
*                                                                                     *
***************************************************************************************
*                                                                                     *
*        Internet: www.segger.com  Support: support@segger.com                        *
*                                                                                     *
***************************************************************************************
*/
// USER START (Optionally insert additional includes)
#include "includes.h"
#include  "app.h"
#include <string.h>
// USER END
/**************************************************************************************
*
*       Defines
*
***************************************************************************************
*/


// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
// USER START (Optionally insert additional static data)
extern GUI_FONT     XBF_Font;
extern __IO uint8_t key_flag;

u8 Flag_Fingerprint = 0;

void FUN_InputFingerprint(void);
void Wipe_FingerprintData(void);
void Wipe_IDFingerprintData(void);

// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
const GUI_WIDGET_CREATE_INFO _aDialogCreateKEY[3] = {
	{ FRAMEWIN_CreateIndirect, "FS", 0, 0, 0, 240, 320, 0, 0x0, 0 },
	{EDIT_CreateIndirect, 	"Edit", GUI_ID_EDIT0, 	10, 35, 160, 40, 0, 0x6, 0 }, 
	{ BUTTON_CreateIndirect, "Del", GUI_ID_BUTTON3, 180, 35, 40, 40, 0, 0x0, 0 },
  /*{ BUTTON_CreateIndirect, "Add", GUI_ID_BUTTON0, 10, 10, 200, 40, 0, 0x0, 0 },//x位置   y位置   长  高
  { BUTTON_CreateIndirect, "Del", GUI_ID_BUTTON1, 10, 50, 200, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Clear", GUI_ID_BUTTON2, 10, 90, 200, 40, 0, 0x0, 0 },*/
//	{ SLIDER_CreateIndirect, "LED_Slider", GUI_ID_SLIDER0, 35, 135, 170, 40, 0, 0x0, 0 },
//	{ BUTTON_CreateIndirect, "Calibration", GUI_ID_BUTTON2, 118-60, 240, 120, 40, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

static const GUI_WIDGET_CREATE_INFO _aDialogCreateIN[] = {
	{ FRAMEWIN_CreateIndirect, "Fingerprint Manage", 0, 0, 0, 240, 320, 0, 0x0, 0 },
	  { BUTTON_CreateIndirect, "Add", GUI_ID_BUTTON0, 10, 10, 200, 40, 0, 0x0, 0 },//x位置   y位置   长  高
  { BUTTON_CreateIndirect, "Del", GUI_ID_BUTTON1, 10, 50, 200, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Clear", GUI_ID_BUTTON2, 10, 90, 200, 40, 0, 0x0, 0 },
	/*{ TEXT_CreateIndirect, 	"state", GUI_ID_TEXT0, 	140, 18, 55, 20, 0, 0x64, 0 }, 
	{ BUTTON_CreateIndirect, "Del", GUI_ID_BUTTON4, 50, 40, 80, 40, 0, 0x0, 0 },*/
//	{ SLIDER_CreateIndirect, "LED_Slider", GUI_ID_SLIDER0, 35, 135, 170, 40, 0, 0x0, 0 },
//	{ BUTTON_CreateIndirect, "Calibration", GUI_ID_BUTTON2, 118-60, 240, 120, 40, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogKEY(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  OS_ERR      err;
  static u8 PasswordFlags = 0;
  // USER START (Optionally insert additional variables)
  uint16_t messagesP[2];
	u8 Password[7];
  char EnterPassword[7];    // 输入的密码
  // USER END

  switch (pMsg->MsgId) 
  {
	  case WM_DELETE:
		// USER START (Optionally insert additional code for further widget initialization)
		  key_flag=1;
		  OS_INFO("KEYapp delete\n");
		  Flag_ICON100 = 0;
			UserApp_Flag = 0;	
			PasswordFlags=0;
			DeleteWindow_KEYBOARD();		
//			LED1_OFF;LED2_OFF;LED3_OFF;
		// USER END
		    break;
	  case WM_INIT_DIALOG:
		//
		// Initialization of 'KEY TEST'
		//
		hItem = pMsg->hWin;
		FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
		FRAMEWIN_SetFont(hItem, GUI_FONT_16B_ASCII);
		FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
		FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
		FRAMEWIN_SetTitleHeight(hItem, 20);
		
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0);
		EDIT_SetTextColor(hItem, EDIT_CI_ENABLED, GUI_BLUE);
		EDIT_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
		EDIT_SetFont(hItem, GUI_FONT_16B_ASCII);
		EDIT_SetTextMode(hItem);
		EDIT_SetText(hItem, "");
		
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON3);
		BUTTON_SetText(hItem, "确定");
		BUTTON_SetFont(hItem, &XBF_Font);
		
		// USER START (Optionally insert additional code for further widget initialization)
		key_flag=0;
		// USER END
		break;

	  case WM_NOTIFY_PARENT:
		Id    = WM_GetId(pMsg->hWinSrc);
		NCode = pMsg->Data.v;
		switch(Id) {
			case GUI_ID_EDIT0: // Notifications sent by 'Edit'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				messagesP[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0);
				messagesP[1]=GUI_ID_EDIT0;
				if(!keypadflag)OSTaskQPost(&AppTaskKeypadTCB,
									(void *)&messagesP,
									2,
									OS_OPT_POST_FIFO,
									&err);
				// USER END
				break;
			case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;

		  case GUI_ID_BUTTON3: // Notifications sent by '确定'
		  switch(NCode) {
		  case WM_NOTIFICATION_CLICKED:

			break;
		  case WM_NOTIFICATION_RELEASED:
			// USER START (Optionally insert code for reacting on notification message)
			EDIT_GetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0), EnterPassword, 7);   // 获取字符串

			GET_AdministratorPassword(Password);                    // 读密码
			//printf("%s\n", Password);
			if (!strcmp(EnterPassword, (char *)Password))
			{
				/*密码正确*/
				DeleteWindow_KEYBOARD();		
				WM_DeleteWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0));    //删除编辑框
				WM_DeleteWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON3));   // 删除确认按键
				PasswordFlags=1;
				
				Flag_Fingerprint=1;
				FUN_InputFingerprint();
			}
			// USER END
			break;
		  case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END			    
				break;
		  }
		  break;
		// USER START (Optionally insert additional code for further Ids)
		// USER END
		}
		break;
	  // USER START (Optionally insert additional message handling)
		case WM_PAINT:	
			GUI_SetBkColor(APPBKCOLOR);
			GUI_SetColor(GUI_MAGENTA);
			GUI_SetColor(APPTEXTCOLOR);
			GUI_Clear();
			
			if (!PasswordFlags)
				GUI_DispStringAt("请输入管理员密码:",10,8);
		break;
	  // USER END
	  default:
		WM_DefaultProc(pMsg);
		break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateKEY TEST
*/
WM_HWIN hWinMiMa;
void FUN_ICON100Clicked(void)
{
	
	hWinMiMa = GUI_CreateDialogBox(_aDialogCreateKEY, GUI_COUNTOF(_aDialogCreateKEY), _cbDialogKEY, WM_HBKWIN, 0, 0);
	OS_INFO("Fingerprint management create\n");
	while(Flag_ICON100)
	{
		GUI_Delay(10); 				
	}
}

void Fingerprint_Management(WM_MESSAGE * pMsg);

// USER START (Optionally insert additional public code)
/*********************************************************************
*
*       CreateKEY TEST
*/
u8 StartFingerprinting = 0;
u8 status = 0;
void FUN_InputFingerprint(void)
{
	WM_DeleteWindow(hWinMiMa);
	Flag_ICON100=0;
	hWinMiMa = GUI_CreateDialogBox(_aDialogCreateIN, GUI_COUNTOF(_aDialogCreateIN), Fingerprint_Management, WM_HBKWIN, 0, 0);
	OS_INFO("Fingerprint management create\n");
	while(Flag_Fingerprint)
	{	
		GUI_Delay(10);
	}
}
u8 ErrorDialog_Loop = 0;
u8 WipeFingerprintData_Loop = 0;
u8 WipeIDFingerprintData_Loop = 0;

void Fingerprint_Management(WM_MESSAGE * pMsg)
{
	 WM_HWIN hItem;
  int     NCode;
  int     Id;

  // USER END

  switch (pMsg->MsgId) 
  {
	  case WM_DELETE:
		// USER START (Optionally insert additional code for further widget initialization)
		  key_flag=1;
		  OS_INFO("kai shi lu zhi wen \n");
		  Flag_Fingerprint=0;
		  UserApp_Flag = 0;	
		  Flag_ICON100=0;
		// USER END
		    break;
	  case WM_INIT_DIALOG:
		//
		// Initialization of 'KEY TEST'
		//
		hItem = pMsg->hWin;
		FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
		FRAMEWIN_SetFont(hItem, GUI_FONT_16B_ASCII);
		FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
		FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
		FRAMEWIN_SetTitleHeight(hItem, 20);
		//
		// Initialization of 'INIT'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
		BUTTON_SetText(hItem, "录入指纹");
		BUTTON_SetFont(hItem, &XBF_Font);
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1);
		BUTTON_SetText(hItem, "删除指纹");
		BUTTON_SetFont(hItem, &XBF_Font);
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON2);
		BUTTON_SetText(hItem, "删除全部指纹");
		BUTTON_SetFont(hItem, &XBF_Font);
		
		// USER START (Optionally insert additional code for further widget initialization)
		key_flag=0;
		// USER END
		break;
	  case WM_NOTIFY_PARENT:
		Id    = WM_GetId(pMsg->hWinSrc);
		NCode = pMsg->Data.v;
		switch(Id) 
		{
			case GUI_ID_BUTTON0: // 录入指纹时的取消
			  switch(NCode) {
				case WM_NOTIFICATION_CLICKED:

				break;
				case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				StartFingerprinting = 1;
				ErrorDialog_Loop=1;
				PS_Sta_IRQDisable();
				ErrorDialog(hWinMiMa,"no","no");
				// USER END
				break;
				case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END			    
				break;
		  }
		  break;
				
			case GUI_ID_BUTTON1: // 删除指纹
				switch(NCode) {
				case WM_NOTIFICATION_CLICKED:

				break;
				case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				WipeIDFingerprintData_Loop=1;
				Wipe_IDFingerprintData();
				// USER END
				break;
				case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END			    
				break;
		  }
		  break;
				
			case GUI_ID_BUTTON2: // 清空指纹库
			  switch(NCode) {
				case WM_NOTIFICATION_CLICKED:

				break;
				case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				WipeFingerprintData_Loop=1;
				Wipe_FingerprintData();
				// USER END
				break;
				case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END			    
				break;
		  }
		  break;
	  // USER START (Optionally insert additional message handling)
		case WM_PAINT:	
			GUI_SetBkColor(APPBKCOLOR);
			GUI_SetColor(GUI_MAGENTA);
			GUI_SetColor(APPTEXTCOLOR);
			GUI_Clear();
		break;
	  // USER END
	  default:
		WM_DefaultProc(pMsg);
		break;
  }
}
}

/* 录指纹窗口 */

static void Status_Display(void);
 
#define ERROR_FRAMEWIN_0 (GUI_ID_USER + 0x00)
#define ERROR_BUTTON_0   (GUI_ID_USER + 0x01)
#define ERROR_BUTTON_1   (GUI_ID_USER + 0x02)
 
static const GUI_WIDGET_CREATE_INFO _aDialogCreateError[] = {
  { FRAMEWIN_CreateIndirect, "Add Fingerprint",  ERROR_FRAMEWIN_0,  20, 50, 200, 160, 0, 0x0, 0 },
  { TEXT_CreateIndirect, 	"state", GUI_ID_TEXT0, 	30, 20, 100, 50, 0, 0x64, 0 },
  { BUTTON_CreateIndirect,   "CLOSE",  ERROR_BUTTON_0,    80,  80,  60,  30,  0, 0x0, 0 },
  //{ BUTTON_CreateIndirect,   "Reboot", ERROR_BUTTON_1,    180, 80,  60,  30,  0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};
static void _cbDialogError(WM_MESSAGE * pMsg) 
{
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'CLOSE'
    //
	hItem = pMsg->hWin;
	FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
	FRAMEWIN_SetFont(hItem, GUI_FONT_16B_ASCII);
	FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
	FRAMEWIN_SetTitleHeight(hItem, 20);
		
	hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
    TEXT_SetFont(hItem, &XBF_Font);
    TEXT_SetTextAlign(hItem, GUI_TA_CENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "请放手指");
	
    hItem = WM_GetDialogItem(pMsg->hWin, ERROR_BUTTON_0);
    BUTTON_SetText(hItem, "OK");
	BUTTON_SetFont(hItem, &XBF_Font);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    if(NCode==WM_NOTIFICATION_RELEASED)
    {
      switch(Id)
      {
        case ERROR_BUTTON_0: // Notifications sent by 'OK'
					EXTI_ClearITPendingBit(PS_Sta_PIN); 
					PS_Sta_IRQEnable();
					StartFingerprinting=0;
					status = 0;
					ErrorDialog_Loop = 0;
					WM_DeleteWindow(pMsg->hWin);

          break;
      }
    }    
    break;
  // USER START (Optionally insert additional message handling)
  case WM_PAINT:
		GUI_SetBkColor(APPBKCOLOR);
		GUI_SetColor(GUI_MAGENTA);
		GUI_SetColor(APPTEXTCOLOR);
		GUI_Clear();

		Status_Display();
   break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

#define GET_StoreID()    1
WM_HWIN ADDhWin;

void ErrorDialog(WM_HWIN hParent,char *string1,char *string2)
{

  u8 ensure = 0;
  u16 ID;

  status = 1<<1; // 放手指
  
  ADDhWin=GUI_CreateDialogBox(_aDialogCreateError,GUI_COUNTOF(_aDialogCreateError),_cbDialogError,WM_HBKWIN,0,0);
  WM_MakeModal(ADDhWin);
  WM_SetStayOnTop(ADDhWin, 1);
  while(ErrorDialog_Loop)
  {
	GUI_Delay(10);
	Status_Display();
	while(StartFingerprinting == 1)
	{
		while(!PS_Sta)
		{
			Status_Display();
			
			GUI_Delay(10);
		}
		
		ensure=PS_GetImage();
		if(ensure==0x00) 
		{
			ensure=PS_GenChar(CharBuffer1);//生成特征
			if(ensure==0x00)
			{
				while(PS_Sta)
				{
					status = 1<<2; // 拿开手指
					GUI_Delay(10);
					Status_Display();
					if (ErrorDialog_Loop==0)
						break;
				}
			}
			else 
			{
				//TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),"录入失败,请重放手指");
				StartFingerprinting = 0;
				status = 0x80;
				continue;
			}
		}
		else 
		{
			//TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),"录入失败,请重放手指");	
			StartFingerprinting = 0;
				status = 0x80;
			continue;
		}
		
		//TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),"请再次放手指");
		while(!PS_Sta)
		{
			status = 1<<3; // 再放手指
			Status_Display();
			GUI_Delay(10);
			if (ErrorDialog_Loop==0)
				break;
		}
		
		ensure=PS_GetImage();
		if(ensure==0x00) 
		{
			ensure=PS_GenChar(CharBuffer2);//生成特征
			if(ensure==0x00)
			{
				ensure=PS_Match();//对比两次指纹
				if(ensure==0x00) 
				{
					ensure=PS_RegModel();
					if(ensure==0x00) 
					{
						ID  = AS608_GET_Idle_ID();
						ensure=PS_StoreChar(CharBuffer2,ID);    // 储存模板
						if(ensure==0x00) 
						{		
								// 指纹录入成功
								AS608_SET_ID(ID);
								StartFingerprinting = 0;
								Status_Display();
								status = 0x01;
						}
						else
						{
							StartFingerprinting = 0;
							status = 0x80;
							continue;
						}
					}else 
					{
						StartFingerprinting = 0;
						status = 0x80;
						continue;
					}
				}
				else 
				{
					StartFingerprinting = 0;
					status = 0x80;
					continue;	
				}
			}
			else 
			{
				StartFingerprinting = 0;
				status = 0x80;
				continue;
			}
		}
		else 
		{
			StartFingerprinting = 0;
			status = 0x80;
			continue;
		}	
	}	
  }
}  
  
  
 static void Status_Display(void)
 {
	if (status>> 7& 1)
		TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"指纹录入失败");

	if (status & 0x01)
		TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"指纹录入成功");
	
	if (status>>1 & (1))
		TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"请放手指");
	
	if (status>>2 & (1))
		TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"请拿开手指");
	
	if (status>>3 & (1))
		TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"请再次放手指");
}
// USER END


/* 清空指纹库 */

static const GUI_WIDGET_CREATE_INFO _aDialogCreateWipe[] = {
  { FRAMEWIN_CreateIndirect, "Wipe Fingerprint",  0,  20, 50, 200, 160, 0, 0x0, 0 },
  { TEXT_CreateIndirect, 	"state", GUI_ID_TEXT0, 	10, 20, 170, 50, 0, 0x80, 0 },
  { BUTTON_CreateIndirect,   "OK",  ERROR_BUTTON_0,    20,  80,  60,  30,  0, 0x0, 0 },
  { BUTTON_CreateIndirect,   "cancel",  ERROR_BUTTON_1,    100,  80,  60,  30,  0, 0x0, 0 },
  //{ BUTTON_CreateIndirect,   "Reboot", ERROR_BUTTON_1,    180, 80,  60,  30,  0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

static void _cbDialogWipeFingerprint(WM_MESSAGE * pMsg)
{
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'CLOSE'
    //
	hItem = pMsg->hWin;
	FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
	FRAMEWIN_SetFont(hItem, GUI_FONT_16B_ASCII);
	FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
	FRAMEWIN_SetTitleHeight(hItem, 20);
		
	hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
    TEXT_SetFont(hItem, &XBF_Font);
    TEXT_SetTextAlign(hItem, GUI_TA_CENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "确定要删除所有指纹吗?");
	
    hItem = WM_GetDialogItem(pMsg->hWin, ERROR_BUTTON_0);
    BUTTON_SetText(hItem, "确定");
	BUTTON_SetFont(hItem, &XBF_Font);
	
	hItem = WM_GetDialogItem(pMsg->hWin, ERROR_BUTTON_1);
    BUTTON_SetText(hItem, "取消");
	BUTTON_SetFont(hItem, &XBF_Font);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    if(NCode==WM_NOTIFICATION_RELEASED)
    {
      switch(Id)
      {
        case ERROR_BUTTON_0: // Notifications sent by 'CLOSE'
		  WM_DeleteWindow(WM_GetDialogItem(pMsg->hWin, ERROR_BUTTON_0));   // 删除确认按键
		  status = 1;
          break;
		  
		 case ERROR_BUTTON_1: // Notifications sent by 'CLOSE'
          WM_DeleteWindow(pMsg->hWin);
		  StartFingerprinting=0;
		  WipeFingerprintData_Loop = 0;
		  status = 0;
          break;
      }
    }    
    break;
  // USER START (Optionally insert additional message handling)
  case WM_PAINT:
		GUI_SetBkColor(APPBKCOLOR);
		GUI_SetColor(GUI_MAGENTA);
		GUI_SetColor(APPTEXTCOLOR);
		GUI_Clear();

		Status_Display();
   break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

void Wipe_FingerprintData(void)
{
	ADDhWin=GUI_CreateDialogBox(_aDialogCreateWipe,GUI_COUNTOF(_aDialogCreateWipe),_cbDialogWipeFingerprint,WM_HBKWIN,0,0);
	WM_MakeModal(ADDhWin);
	WM_SetStayOnTop(ADDhWin, 1);
	while(WipeFingerprintData_Loop)
	{
		GUI_Delay(10);
		
		if (status == 1)
		{
			if (PS_Empty() == 0)
			{
				AS608_Clear_All_ID();
				TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"删除所有指纹成功\0");
			}
			else
			{
				TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"删除所有指纹失败\0");
			}
			
			status = 0;
		}
	}
}

/* 删除最后录入的指纹 */

static void _cbDialogWipeIDFingerprint(WM_MESSAGE * pMsg)
{
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'CLOSE'
    //
	hItem = pMsg->hWin;
	FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
	FRAMEWIN_SetFont(hItem, GUI_FONT_16B_ASCII);
	FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
	FRAMEWIN_SetTitleHeight(hItem, 20);
		
	hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
    TEXT_SetFont(hItem, &XBF_Font);
    TEXT_SetTextAlign(hItem, GUI_TA_CENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "要删除最后一个指纹吗?");
	
    hItem = WM_GetDialogItem(pMsg->hWin, ERROR_BUTTON_0);
    BUTTON_SetText(hItem, "确定");
	BUTTON_SetFont(hItem, &XBF_Font);
	
	hItem = WM_GetDialogItem(pMsg->hWin, ERROR_BUTTON_1);
    BUTTON_SetText(hItem, "取消");
	BUTTON_SetFont(hItem, &XBF_Font);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    if(NCode==WM_NOTIFICATION_RELEASED)
    {
      switch(Id)
      {
        case ERROR_BUTTON_0: // Notifications sent by 'CLOSE'
		  WM_DeleteWindow(WM_GetDialogItem(pMsg->hWin, ERROR_BUTTON_0));   // 删除确认按键
		  status = 1;
          break;
		  
		 case ERROR_BUTTON_1: // Notifications sent by 'CLOSE'
          WM_DeleteWindow(pMsg->hWin);
		  StartFingerprinting=0;
		  WipeFingerprintData_Loop = 0;
		  status = 0;
          break;
      }
    }    
    break;
  // USER START (Optionally insert additional message handling)
  case WM_PAINT:
		GUI_SetBkColor(APPBKCOLOR);
		GUI_SetColor(GUI_MAGENTA);
		GUI_SetColor(APPTEXTCOLOR);
		GUI_Clear();

		Status_Display();
   break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

void Wipe_IDFingerprintData(void)
{
	u16 Last_ID;
	ADDhWin=GUI_CreateDialogBox(_aDialogCreateWipe,GUI_COUNTOF(_aDialogCreateWipe),_cbDialogWipeIDFingerprint,WM_HBKWIN,0,0);
	WM_MakeModal(ADDhWin);
	WM_SetStayOnTop(ADDhWin, 1);

	while(WipeIDFingerprintData_Loop)
	{
		GUI_Delay(10);
		
		if (status == 1)
		{
			Last_ID = AS608_GET_Last_ID();
			if (PS_DeletChar(Last_ID, 1) == 0)
			{
				AS608_Del_ID(Last_ID);
				TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"删除指纹成功\0");
			}
			else
			{
				TEXT_SetText(WM_GetDialogItem(ADDhWin, GUI_ID_TEXT0),"删除指纹失败\0");
			}
			
			status = 0;
		}
	}
}

/*************************** End of file ****************************/
